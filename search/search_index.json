{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Mac Notifications Documentation : https://jorricks.github.io/macos-notifications/ Source Code : https://github.com/Jorricks/macos-notifications mac-notification is a Python library to make it as easy as possible to create interactable notifications. Installation To use macos-notifications, first install it using pip: pip install macos-notifications Installed Features \ud83d\ude80 Easy python interface. It's as simple as ' client.create_notification(title=\"Meeting starts now!\", subtitle=\"Team Standup\") ' \ud83d\udca5 Ability to add action buttons with callbacks! \ud83d\udcdd Ability to reply to notifications! \u231a Delayed notifications. \u23f1\ufe0f Automatically time out the notification listener. \ud83d\udce6 Just pyobjc as a dependency. Example from functools import partial from mac_notifications import client if __name__ == \"__main__\" : client . create_notification ( title = \"Meeting starts now!\" , subtitle = \"Team Standup\" , icon = \"/Users/jorrick/zoom.png\" , sound = \"Frog\" , action_button_str = \"Join zoom meeting\" , action_callback = partial ( join_zoom_meeting , conf_number = zoom_conf_number ) ) A simple example. Please look in the docs for more examples like this: Limitations You need to keep your application running while waiting for the callback to happen. Currently, we are only supporting the old deprecated user notifications . Soon we will also make the new implementation available.","title":"Home"},{"location":"#mac-notifications","text":"Documentation : https://jorricks.github.io/macos-notifications/ Source Code : https://github.com/Jorricks/macos-notifications mac-notification is a Python library to make it as easy as possible to create interactable notifications.","title":"Mac Notifications"},{"location":"#installation","text":"To use macos-notifications, first install it using pip: pip install macos-notifications Installed","title":"Installation"},{"location":"#features","text":"\ud83d\ude80 Easy python interface. It's as simple as ' client.create_notification(title=\"Meeting starts now!\", subtitle=\"Team Standup\") ' \ud83d\udca5 Ability to add action buttons with callbacks! \ud83d\udcdd Ability to reply to notifications! \u231a Delayed notifications. \u23f1\ufe0f Automatically time out the notification listener. \ud83d\udce6 Just pyobjc as a dependency.","title":"Features"},{"location":"#example","text":"from functools import partial from mac_notifications import client if __name__ == \"__main__\" : client . create_notification ( title = \"Meeting starts now!\" , subtitle = \"Team Standup\" , icon = \"/Users/jorrick/zoom.png\" , sound = \"Frog\" , action_button_str = \"Join zoom meeting\" , action_callback = partial ( join_zoom_meeting , conf_number = zoom_conf_number ) ) A simple example. Please look in the docs for more examples like this:","title":"Example"},{"location":"#limitations","text":"You need to keep your application running while waiting for the callback to happen. Currently, we are only supporting the old deprecated user notifications . Soon we will also make the new implementation available.","title":"Limitations"},{"location":"examples/","text":"Examples On this page we will list several examples. Let's start with a demonstration of the last example of this page. Simple notification from mac_notifications import client if __name__ == \"__main__\" : client . create_notification ( title = \"Meeting starts now!\" , subtitle = \"Team Standup\" ) Notification with a reply callback from __future__ import annotations import time from datetime import timedelta from pathlib import Path from mac_notifications import client if __name__ == \"__main__\" : print ( \"You have to press the notification within 30 seconds for it to work.\" ) client . create_notification ( title = \"Cool notification\" , subtitle = \"Subtitle of the notification\" , text = \"Hello, I contain info\" , icon = Path ( __file__ ) . parent / \"zoom.png\" , delay = timedelta ( milliseconds = 500 ), reply_button_str = \"Reply to this notification\" , reply_callback = lambda reply : print ( f \"Replied { reply =} \" ), snooze_button_str = \"Or click me\" , ) time . sleep ( 30 ) client . stop_listening_for_callbacks () Notification with an action from __future__ import annotations import time from functools import partial from pathlib import Path from mac_notifications import client def join_zoom_meeting ( conf_number : int | str ) -> None : \"\"\"Join the zoom meeting\"\"\" # import subprocess # subprocess.run(f'open \"zoommtg://zoom.us/join?action=join&confno={conf_number}&browser=chrome\"', shell=True) print ( f \"Opened zoom into meeting with { conf_number =} .\" ) if __name__ == \"__main__\" : print ( client . get_notification_manager () . get_active_running_notifications ()) client . create_notification ( title = \"Meeting starts now!\" , subtitle = \"Standup time :)\" , icon = Path ( __file__ ) . parent / \"zoom.png\" , action_button_str = \"Join zoom meeting\" , action_callback = partial ( join_zoom_meeting , conf_number = \"12345678\" ), ) time . sleep ( 30 ) client . stop_listening_for_callbacks () Multiple notifications Give this a try. Play around with the notifications. Notice that when you close the notification, the count doesn't go down and the application stays running forever. This is one of the limitations of using Python for these notifications as we don't know whether the notification is still present or not. import time from mac_notifications import client if __name__ == \"__main__\" : print ( f \"Active number of notifications: { client . get_notification_manager () . get_active_running_notifications () } \" ) client . create_notification ( title = \"Action notification\" , subtitle = \"Subtitle of the notification\" , action_button_str = \"Perform an action\" , action_callback = lambda : print ( \"Pressed action button\" ), ) time . sleep ( 1 ) client . create_notification ( title = \"Reply notification\" , subtitle = \"Subtitle of the notification\" , reply_button_str = \"Reply to this notification\" , reply_callback = lambda reply : print ( f \"Replied { reply =} \" ), ) while client . get_notification_manager () . get_active_running_notifications () > 0 : time . sleep ( 1 ) print ( f \"Active number of notifications: { client . get_notification_manager () . get_active_running_notifications () } \" ) client . stop_listening_for_callbacks ()","title":"Examples"},{"location":"examples/#examples","text":"On this page we will list several examples. Let's start with a demonstration of the last example of this page.","title":"Examples"},{"location":"examples/#simple-notification","text":"from mac_notifications import client if __name__ == \"__main__\" : client . create_notification ( title = \"Meeting starts now!\" , subtitle = \"Team Standup\" )","title":"Simple notification"},{"location":"examples/#notification-with-a-reply-callback","text":"from __future__ import annotations import time from datetime import timedelta from pathlib import Path from mac_notifications import client if __name__ == \"__main__\" : print ( \"You have to press the notification within 30 seconds for it to work.\" ) client . create_notification ( title = \"Cool notification\" , subtitle = \"Subtitle of the notification\" , text = \"Hello, I contain info\" , icon = Path ( __file__ ) . parent / \"zoom.png\" , delay = timedelta ( milliseconds = 500 ), reply_button_str = \"Reply to this notification\" , reply_callback = lambda reply : print ( f \"Replied { reply =} \" ), snooze_button_str = \"Or click me\" , ) time . sleep ( 30 ) client . stop_listening_for_callbacks ()","title":"Notification with a reply callback"},{"location":"examples/#notification-with-an-action","text":"from __future__ import annotations import time from functools import partial from pathlib import Path from mac_notifications import client def join_zoom_meeting ( conf_number : int | str ) -> None : \"\"\"Join the zoom meeting\"\"\" # import subprocess # subprocess.run(f'open \"zoommtg://zoom.us/join?action=join&confno={conf_number}&browser=chrome\"', shell=True) print ( f \"Opened zoom into meeting with { conf_number =} .\" ) if __name__ == \"__main__\" : print ( client . get_notification_manager () . get_active_running_notifications ()) client . create_notification ( title = \"Meeting starts now!\" , subtitle = \"Standup time :)\" , icon = Path ( __file__ ) . parent / \"zoom.png\" , action_button_str = \"Join zoom meeting\" , action_callback = partial ( join_zoom_meeting , conf_number = \"12345678\" ), ) time . sleep ( 30 ) client . stop_listening_for_callbacks ()","title":"Notification with an action"},{"location":"examples/#multiple-notifications","text":"Give this a try. Play around with the notifications. Notice that when you close the notification, the count doesn't go down and the application stays running forever. This is one of the limitations of using Python for these notifications as we don't know whether the notification is still present or not. import time from mac_notifications import client if __name__ == \"__main__\" : print ( f \"Active number of notifications: { client . get_notification_manager () . get_active_running_notifications () } \" ) client . create_notification ( title = \"Action notification\" , subtitle = \"Subtitle of the notification\" , action_button_str = \"Perform an action\" , action_callback = lambda : print ( \"Pressed action button\" ), ) time . sleep ( 1 ) client . create_notification ( title = \"Reply notification\" , subtitle = \"Subtitle of the notification\" , reply_button_str = \"Reply to this notification\" , reply_callback = lambda reply : print ( f \"Replied { reply =} \" ), ) while client . get_notification_manager () . get_active_running_notifications () > 0 : time . sleep ( 1 ) print ( f \"Active number of notifications: { client . get_notification_manager () . get_active_running_notifications () } \" ) client . stop_listening_for_callbacks ()","title":"Multiple notifications"},{"location":"faq/","text":"FAQ Why did you create this library ? I wanted a library that did not depend on any non-python tools (so you had to go around and install that). Instead, I wanted a library where you install the pip packages and you are done. Later I realised how hard it was to integrate correctly with PyOBJC. Also, I had a hard time finding any examples on how to easily integrate this in a non-blocking fashion with my tool. Hence, I figured I should set it up to be as user-friendly as possible and share it with the world ;)! My notifications don't show up with the text I mentioned Unfortunately, you first need to allow Python to create notifications. Instructions are similar to what can be found here . The application will be named 'Python'. Your settings should look similar to this:","title":"Frequently asked questions"},{"location":"faq/#faq","text":"Why did you create this library ? I wanted a library that did not depend on any non-python tools (so you had to go around and install that). Instead, I wanted a library where you install the pip packages and you are done. Later I realised how hard it was to integrate correctly with PyOBJC. Also, I had a hard time finding any examples on how to easily integrate this in a non-blocking fashion with my tool. Hence, I figured I should set it up to be as user-friendly as possible and share it with the world ;)! My notifications don't show up with the text I mentioned Unfortunately, you first need to allow Python to create notifications. Instructions are similar to what can be found here . The application will be named 'Python'. Your settings should look similar to this:","title":"FAQ"},{"location":"release-notes/","text":"Release Notes Latest changes 0.1.5 - 1st August 2022 \ud83d\udcdd Python example was missing name filter. 0.1.4 - 1st August 2022 \ud83d\udc1b Multiple notifications in the same thread gave exceptions. Now you can send as many notifications as you want. 0.1.3 - 31 July 2022 \ud83d\udcdd Out-dated python example on main page 0.1.2 - 26 July 2022 \ud83d\udcdd Documentation update \ud83d\udcdd Remove requirements from docs \ud83d\udcdd Update badges 0.1.1 - 26 July 2022 \ud83d\udcdd Fix broken image in documentation 0.1.0 - 24 July 2022 \ud83d\udd27 Rename all references of mac-notifications to macos-notifications 0.0.1a1 - 24 July 2022 \ud83d\udd27 Rename project as mac-notifications was taken on pypi Initial release: 0.0.1a0 - 23 July 2022 \ud83d\ude80 Easy python interface. It's as simple as ' client.create_notification(title=\"Meeting starts now!\", subtitle=\"Team Standup\") ' \ud83d\udca5 Ability to add action buttons with callbacks! \ud83d\udcdd Ability to reply to notifications! \u231a Delayed notifications. \u23f1\ufe0f Automatically time out the notification listener. \ud83d\udce6 Just two packages (which is really just one package) as a dependency","title":"Release notes"},{"location":"release-notes/#release-notes","text":"","title":"Release Notes"},{"location":"release-notes/#latest-changes","text":"","title":"Latest changes"},{"location":"release-notes/#015-1st-august-2022","text":"\ud83d\udcdd Python example was missing name filter.","title":"0.1.5 - 1st August 2022"},{"location":"release-notes/#014-1st-august-2022","text":"\ud83d\udc1b Multiple notifications in the same thread gave exceptions. Now you can send as many notifications as you want.","title":"0.1.4 - 1st August 2022"},{"location":"release-notes/#013-31-july-2022","text":"\ud83d\udcdd Out-dated python example on main page","title":"0.1.3 - 31 July 2022"},{"location":"release-notes/#012-26-july-2022","text":"\ud83d\udcdd Documentation update \ud83d\udcdd Remove requirements from docs \ud83d\udcdd Update badges","title":"0.1.2 - 26 July 2022"},{"location":"release-notes/#011-26-july-2022","text":"\ud83d\udcdd Fix broken image in documentation","title":"0.1.1 - 26 July 2022"},{"location":"release-notes/#010-24-july-2022","text":"\ud83d\udd27 Rename all references of mac-notifications to macos-notifications","title":"0.1.0 - 24 July 2022"},{"location":"release-notes/#001a1-24-july-2022","text":"\ud83d\udd27 Rename project as mac-notifications was taken on pypi","title":"0.0.1a1 - 24 July 2022"},{"location":"release-notes/#initial-release-001a0-23-july-2022","text":"\ud83d\ude80 Easy python interface. It's as simple as ' client.create_notification(title=\"Meeting starts now!\", subtitle=\"Team Standup\") ' \ud83d\udca5 Ability to add action buttons with callbacks! \ud83d\udcdd Ability to reply to notifications! \u231a Delayed notifications. \u23f1\ufe0f Automatically time out the notification listener. \ud83d\udce6 Just two packages (which is really just one package) as a dependency","title":"Initial release: 0.0.1a0 - 23 July 2022"},{"location":"user_guide/","text":"User guide The goal of this library is to make it as easy to use as possible. This page will list the documentation of the client function. For examples, please check the examples . create_notification ( title = 'Notification' , subtitle = None , text = None , icon = None , sound = None , delay = timedelta (), action_button_str = None , action_callback = None , reply_button_str = None , reply_callback = None , snooze_button_str = None ) Create a MacOS notification :) Parameters: Name Type Description Default title str Title of the notification. 'Notification' subtitle str | None The subtitle of the notification. None text str | None The text/main body of the notification. None icon str | Path | None An Icon you would like to set on the right bottom. None delay timedelta Delay before showing the message. timedelta () action_button_str str | None The string of the Action button. None action_callback Callable [[], None] | None The function to call when the action button is pressed. None reply_button_str str | None The string of the Reply button. None reply_callback Callable [[ str ], None] | None The function to call with the replied text. None snooze_button_str str | None This is a useless button that closes the notification (but not the process). Think of this as a snooze button. None Source code in mac_notifications/client.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def create_notification ( title : str = \"Notification\" , subtitle : str | None = None , text : str | None = None , icon : str | Path | None = None , sound : str | None = None , delay : timedelta = timedelta (), action_button_str : str | None = None , action_callback : Callable [[], None ] | None = None , reply_button_str : str | None = None , reply_callback : Callable [[ str ], None ] | None = None , snooze_button_str : str | None = None , ) -> Notification : \"\"\" Create a MacOS notification :) :param title: Title of the notification. :param subtitle: The subtitle of the notification. :param text: The text/main body of the notification. :param icon: An Icon you would like to set on the right bottom. :param delay: Delay before showing the message. :param action_button_str: The string of the Action button. :param action_callback: The function to call when the action button is pressed. :param reply_button_str: The string of the Reply button. :param reply_callback: The function to call with the replied text. :param snooze_button_str: This is a useless button that closes the notification (but not the process). Think of this as a snooze button. \"\"\" notification_config = NotificationConfig ( title = title , subtitle = subtitle , text = text , icon = ( str ( icon . resolve ()) if isinstance ( icon , Path ) else icon ) if icon else None , sound = sound , delay = delay , action_button_str = action_button_str , action_callback = action_callback , reply_button_str = reply_button_str , reply_callback = reply_callback , snooze_button_str = snooze_button_str , ) return get_notification_manager () . create_notification ( notification_config )","title":"User guide"},{"location":"user_guide/#user-guide","text":"The goal of this library is to make it as easy to use as possible. This page will list the documentation of the client function. For examples, please check the examples .","title":"User guide"},{"location":"user_guide/#mac_notifications.client.create_notification","text":"Create a MacOS notification :) Parameters: Name Type Description Default title str Title of the notification. 'Notification' subtitle str | None The subtitle of the notification. None text str | None The text/main body of the notification. None icon str | Path | None An Icon you would like to set on the right bottom. None delay timedelta Delay before showing the message. timedelta () action_button_str str | None The string of the Action button. None action_callback Callable [[], None] | None The function to call when the action button is pressed. None reply_button_str str | None The string of the Reply button. None reply_callback Callable [[ str ], None] | None The function to call with the replied text. None snooze_button_str str | None This is a useless button that closes the notification (but not the process). Think of this as a snooze button. None Source code in mac_notifications/client.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def create_notification ( title : str = \"Notification\" , subtitle : str | None = None , text : str | None = None , icon : str | Path | None = None , sound : str | None = None , delay : timedelta = timedelta (), action_button_str : str | None = None , action_callback : Callable [[], None ] | None = None , reply_button_str : str | None = None , reply_callback : Callable [[ str ], None ] | None = None , snooze_button_str : str | None = None , ) -> Notification : \"\"\" Create a MacOS notification :) :param title: Title of the notification. :param subtitle: The subtitle of the notification. :param text: The text/main body of the notification. :param icon: An Icon you would like to set on the right bottom. :param delay: Delay before showing the message. :param action_button_str: The string of the Action button. :param action_callback: The function to call when the action button is pressed. :param reply_button_str: The string of the Reply button. :param reply_callback: The function to call with the replied text. :param snooze_button_str: This is a useless button that closes the notification (but not the process). Think of this as a snooze button. \"\"\" notification_config = NotificationConfig ( title = title , subtitle = subtitle , text = text , icon = ( str ( icon . resolve ()) if isinstance ( icon , Path ) else icon ) if icon else None , sound = sound , delay = delay , action_button_str = action_button_str , action_callback = action_callback , reply_button_str = reply_button_str , reply_callback = reply_callback , snooze_button_str = snooze_button_str , ) return get_notification_manager () . create_notification ( notification_config )","title":"create_notification"},{"location":"code/client/","text":"The client When you are looking to integrate macos-notifications with your project, the client is the first place to look. If you have a service that periodically restarts, you might want to take a look at the CacheClient . client create_notification ( title = 'Notification' , subtitle = None , text = None , icon = None , sound = None , delay = timedelta (), action_button_str = None , action_callback = None , reply_button_str = None , reply_callback = None , snooze_button_str = None ) Create a MacOS notification :) Parameters: Name Type Description Default title str Title of the notification. 'Notification' subtitle str | None The subtitle of the notification. None text str | None The text/main body of the notification. None icon str | Path | None An Icon you would like to set on the right bottom. None delay timedelta Delay before showing the message. timedelta () action_button_str str | None The string of the Action button. None action_callback Callable [[], None] | None The function to call when the action button is pressed. None reply_button_str str | None The string of the Reply button. None reply_callback Callable [[ str ], None] | None The function to call with the replied text. None snooze_button_str str | None This is a useless button that closes the notification (but not the process). Think of this as a snooze button. None Source code in mac_notifications/client.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def create_notification ( title : str = \"Notification\" , subtitle : str | None = None , text : str | None = None , icon : str | Path | None = None , sound : str | None = None , delay : timedelta = timedelta (), action_button_str : str | None = None , action_callback : Callable [[], None ] | None = None , reply_button_str : str | None = None , reply_callback : Callable [[ str ], None ] | None = None , snooze_button_str : str | None = None , ) -> Notification : \"\"\" Create a MacOS notification :) :param title: Title of the notification. :param subtitle: The subtitle of the notification. :param text: The text/main body of the notification. :param icon: An Icon you would like to set on the right bottom. :param delay: Delay before showing the message. :param action_button_str: The string of the Action button. :param action_callback: The function to call when the action button is pressed. :param reply_button_str: The string of the Reply button. :param reply_callback: The function to call with the replied text. :param snooze_button_str: This is a useless button that closes the notification (but not the process). Think of this as a snooze button. \"\"\" notification_config = NotificationConfig ( title = title , subtitle = subtitle , text = text , icon = ( str ( icon . resolve ()) if isinstance ( icon , Path ) else icon ) if icon else None , sound = sound , delay = delay , action_button_str = action_button_str , action_callback = action_callback , reply_button_str = reply_button_str , reply_callback = reply_callback , snooze_button_str = snooze_button_str , ) return get_notification_manager () . create_notification ( notification_config ) get_notification_manager () Return the NotificationManager object. Source code in mac_notifications/client.py 19 20 21 def get_notification_manager () -> NotificationManager : \"\"\"Return the NotificationManager object.\"\"\" return NotificationManager () More advanced usages To get a bit more information about the amount of notifications that are still active, you can use the following function: get_notification_manager () Return the NotificationManager object. Source code in mac_notifications/client.py 19 20 21 def get_notification_manager () -> NotificationManager : \"\"\"Return the NotificationManager object.\"\"\" return NotificationManager ()","title":"Client"},{"location":"code/client/#the-client","text":"When you are looking to integrate macos-notifications with your project, the client is the first place to look. If you have a service that periodically restarts, you might want to take a look at the CacheClient .","title":"The client"},{"location":"code/client/#mac_notifications.client","text":"","title":"client"},{"location":"code/client/#mac_notifications.client.create_notification","text":"Create a MacOS notification :) Parameters: Name Type Description Default title str Title of the notification. 'Notification' subtitle str | None The subtitle of the notification. None text str | None The text/main body of the notification. None icon str | Path | None An Icon you would like to set on the right bottom. None delay timedelta Delay before showing the message. timedelta () action_button_str str | None The string of the Action button. None action_callback Callable [[], None] | None The function to call when the action button is pressed. None reply_button_str str | None The string of the Reply button. None reply_callback Callable [[ str ], None] | None The function to call with the replied text. None snooze_button_str str | None This is a useless button that closes the notification (but not the process). Think of this as a snooze button. None Source code in mac_notifications/client.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def create_notification ( title : str = \"Notification\" , subtitle : str | None = None , text : str | None = None , icon : str | Path | None = None , sound : str | None = None , delay : timedelta = timedelta (), action_button_str : str | None = None , action_callback : Callable [[], None ] | None = None , reply_button_str : str | None = None , reply_callback : Callable [[ str ], None ] | None = None , snooze_button_str : str | None = None , ) -> Notification : \"\"\" Create a MacOS notification :) :param title: Title of the notification. :param subtitle: The subtitle of the notification. :param text: The text/main body of the notification. :param icon: An Icon you would like to set on the right bottom. :param delay: Delay before showing the message. :param action_button_str: The string of the Action button. :param action_callback: The function to call when the action button is pressed. :param reply_button_str: The string of the Reply button. :param reply_callback: The function to call with the replied text. :param snooze_button_str: This is a useless button that closes the notification (but not the process). Think of this as a snooze button. \"\"\" notification_config = NotificationConfig ( title = title , subtitle = subtitle , text = text , icon = ( str ( icon . resolve ()) if isinstance ( icon , Path ) else icon ) if icon else None , sound = sound , delay = delay , action_button_str = action_button_str , action_callback = action_callback , reply_button_str = reply_button_str , reply_callback = reply_callback , snooze_button_str = snooze_button_str , ) return get_notification_manager () . create_notification ( notification_config )","title":"create_notification"},{"location":"code/client/#mac_notifications.client.get_notification_manager","text":"Return the NotificationManager object. Source code in mac_notifications/client.py 19 20 21 def get_notification_manager () -> NotificationManager : \"\"\"Return the NotificationManager object.\"\"\" return NotificationManager ()","title":"get_notification_manager"},{"location":"code/client/#more-advanced-usages","text":"To get a bit more information about the amount of notifications that are still active, you can use the following function:","title":"More advanced usages"},{"location":"code/client/#mac_notifications.client.get_notification_manager","text":"Return the NotificationManager object. Source code in mac_notifications/client.py 19 20 21 def get_notification_manager () -> NotificationManager : \"\"\"Return the NotificationManager object.\"\"\" return NotificationManager ()","title":"get_notification_manager"},{"location":"code/listener_process/","text":"Notification listener process The class doc explain it all :) NotificationProcess Bases: Process This is a simple process to launch a notification in a separate process. Why you may ask? First, the way we need to launch a notification using a class, this class can only be instantiated once in a process. Hence, for simple notifications we create a new process and then immediately stop it after the notification was launched. Second, waiting for the user interaction with a notification is a blocking operation. Because it is a blocking operation, if we want to be able to receive any user interaction from the notification, without completely halting/freezing our main process, we need to open it in a background process. Source code in mac_notifications/listener_process.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class NotificationProcess ( Process ): \"\"\" This is a simple process to launch a notification in a separate process. Why you may ask? First, the way we need to launch a notification using a class, this class can only be instantiated once in a process. Hence, for simple notifications we create a new process and then immediately stop it after the notification was launched. Second, waiting for the user interaction with a notification is a blocking operation. Because it is a blocking operation, if we want to be able to receive any user interaction from the notification, without completely halting/freezing our main process, we need to open it in a background process. \"\"\" def __init__ ( self , notification_config : JSONNotificationConfig , queue : SimpleQueue | None ): super () . __init__ () self . notification_config = notification_config self . queue = queue def run ( self ) -> None : notification_sender . create_notification ( self . notification_config , self . queue ) . send ()","title":"Notification listener process"},{"location":"code/listener_process/#notification-listener-process","text":"The class doc explain it all :)","title":"Notification listener process"},{"location":"code/listener_process/#mac_notifications.listener_process.NotificationProcess","text":"Bases: Process This is a simple process to launch a notification in a separate process. Why you may ask? First, the way we need to launch a notification using a class, this class can only be instantiated once in a process. Hence, for simple notifications we create a new process and then immediately stop it after the notification was launched. Second, waiting for the user interaction with a notification is a blocking operation. Because it is a blocking operation, if we want to be able to receive any user interaction from the notification, without completely halting/freezing our main process, we need to open it in a background process. Source code in mac_notifications/listener_process.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class NotificationProcess ( Process ): \"\"\" This is a simple process to launch a notification in a separate process. Why you may ask? First, the way we need to launch a notification using a class, this class can only be instantiated once in a process. Hence, for simple notifications we create a new process and then immediately stop it after the notification was launched. Second, waiting for the user interaction with a notification is a blocking operation. Because it is a blocking operation, if we want to be able to receive any user interaction from the notification, without completely halting/freezing our main process, we need to open it in a background process. \"\"\" def __init__ ( self , notification_config : JSONNotificationConfig , queue : SimpleQueue | None ): super () . __init__ () self . notification_config = notification_config self . queue = queue def run ( self ) -> None : notification_sender . create_notification ( self . notification_config , self . queue ) . send ()","title":"NotificationProcess"},{"location":"code/manager/","text":"Notification Manager The module that is responsible for managing the notifications over time & enabling callbacks to be executed. NotificationManager The NotificationManager is responsible for managing the notifications. This includes the following: - Starting new notifications. - Starting the Callback Executor thread in the background. Source code in mac_notifications/manager.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 class NotificationManager ( metaclass = Singleton ): \"\"\" The NotificationManager is responsible for managing the notifications. This includes the following: - Starting new notifications. - Starting the Callback Executor thread in the background. \"\"\" def __init__ ( self ): self . _callback_queue : SimpleQueue = SimpleQueue () self . _callback_executor_event : Event = Event () self . _callback_executor_thread : CallbackExecutorThread | None = None self . _callback_listener_process : NotificationProcess | None = None # Specify that once we stop our application, self.cleanup should run atexit . register ( self . cleanup ) # Specify that when we get a keyboard interrupt, this function should handle it signal . signal ( signal . SIGINT , handler = self . catch_keyboard_interrupt ) def create_callback_executor_thread ( self ) -> None : \"\"\"Creates the callback executor thread and sets the _callback_executor_event.\"\"\" if not ( self . _callback_executor_thread and self . _callback_executor_thread . is_alive ()): self . _callback_executor_thread = CallbackExecutorThread ( keep_running = self . _callback_executor_event , callback_queue = self . _callback_queue , ) self . _callback_executor_event . set () self . _callback_executor_thread . start () def create_notification ( self , notification_config : NotificationConfig ) -> Notification : \"\"\" Create a notification and the corresponding processes if required for a notification with callbacks. :param notification_config: The configuration for the notification. \"\"\" json_config = notification_config . to_json_notification () if not notification_config . contains_callback or self . _callback_listener_process is not None : # We can send it directly and kill the process after as we don't need to listen for callbacks. new_process = NotificationProcess ( json_config , None ) new_process . start () new_process . join ( timeout = 5 ) else : # We need to also start a listener, so we send the json through a separate process. self . _callback_listener_process = NotificationProcess ( json_config , self . _callback_queue ) self . _callback_listener_process . start () self . create_callback_executor_thread () if notification_config . contains_callback : _FIFO_LIST . append ( notification_config . uid ) _NOTIFICATION_MAP [ notification_config . uid ] = notification_config self . clear_old_notifications () return Notification ( notification_config . uid ) @staticmethod def clear_old_notifications () -> None : \"\"\"Removes old notifications when we are passed our threshold.\"\"\" while len ( _FIFO_LIST ) > _MAX_NUMBER_OF_CALLBACKS_TO_TRACK : clear_notification_from_existence ( _FIFO_LIST . pop ( 0 )) @staticmethod def get_active_running_notifications () -> int : \"\"\" WARNING! This is wildly inaccurate. Does an attempt to get the number of active running notifications. However, if a user snoozed or deleted the notification, we don't get an update. \"\"\" return len ( _NOTIFICATION_MAP ) def catch_keyboard_interrupt ( self , * args ) -> None : \"\"\"We catch the keyboard interrupt but also pass it onto the user program.\"\"\" self . cleanup () sys . exit ( signal . SIGINT ) def cleanup ( self ) -> None : \"\"\"Stop all processes related to the Notification callback handling.\"\"\" if self . _callback_executor_thread : self . _callback_executor_event . clear () self . _callback_executor_thread . join () if self . _callback_listener_process : self . _callback_listener_process . kill () self . _callback_executor_thread = None self . _callback_listener_process = None _NOTIFICATION_MAP . clear () _FIFO_LIST . clear () catch_keyboard_interrupt ( * args ) We catch the keyboard interrupt but also pass it onto the user program. Source code in mac_notifications/manager.py 108 109 110 111 def catch_keyboard_interrupt ( self , * args ) -> None : \"\"\"We catch the keyboard interrupt but also pass it onto the user program.\"\"\" self . cleanup () sys . exit ( signal . SIGINT ) cleanup () Stop all processes related to the Notification callback handling. Source code in mac_notifications/manager.py 113 114 115 116 117 118 119 120 121 122 123 def cleanup ( self ) -> None : \"\"\"Stop all processes related to the Notification callback handling.\"\"\" if self . _callback_executor_thread : self . _callback_executor_event . clear () self . _callback_executor_thread . join () if self . _callback_listener_process : self . _callback_listener_process . kill () self . _callback_executor_thread = None self . _callback_listener_process = None _NOTIFICATION_MAP . clear () _FIFO_LIST . clear () clear_old_notifications () staticmethod Removes old notifications when we are passed our threshold. Source code in mac_notifications/manager.py 93 94 95 96 97 @staticmethod def clear_old_notifications () -> None : \"\"\"Removes old notifications when we are passed our threshold.\"\"\" while len ( _FIFO_LIST ) > _MAX_NUMBER_OF_CALLBACKS_TO_TRACK : clear_notification_from_existence ( _FIFO_LIST . pop ( 0 )) create_callback_executor_thread () Creates the callback executor thread and sets the _callback_executor_event. Source code in mac_notifications/manager.py 60 61 62 63 64 65 66 67 68 def create_callback_executor_thread ( self ) -> None : \"\"\"Creates the callback executor thread and sets the _callback_executor_event.\"\"\" if not ( self . _callback_executor_thread and self . _callback_executor_thread . is_alive ()): self . _callback_executor_thread = CallbackExecutorThread ( keep_running = self . _callback_executor_event , callback_queue = self . _callback_queue , ) self . _callback_executor_event . set () self . _callback_executor_thread . start () create_notification ( notification_config ) Create a notification and the corresponding processes if required for a notification with callbacks. Parameters: Name Type Description Default notification_config NotificationConfig The configuration for the notification. required Source code in mac_notifications/manager.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def create_notification ( self , notification_config : NotificationConfig ) -> Notification : \"\"\" Create a notification and the corresponding processes if required for a notification with callbacks. :param notification_config: The configuration for the notification. \"\"\" json_config = notification_config . to_json_notification () if not notification_config . contains_callback or self . _callback_listener_process is not None : # We can send it directly and kill the process after as we don't need to listen for callbacks. new_process = NotificationProcess ( json_config , None ) new_process . start () new_process . join ( timeout = 5 ) else : # We need to also start a listener, so we send the json through a separate process. self . _callback_listener_process = NotificationProcess ( json_config , self . _callback_queue ) self . _callback_listener_process . start () self . create_callback_executor_thread () if notification_config . contains_callback : _FIFO_LIST . append ( notification_config . uid ) _NOTIFICATION_MAP [ notification_config . uid ] = notification_config self . clear_old_notifications () return Notification ( notification_config . uid ) get_active_running_notifications () staticmethod WARNING! This is wildly inaccurate. Does an attempt to get the number of active running notifications. However, if a user snoozed or deleted the notification, we don't get an update. Source code in mac_notifications/manager.py 99 100 101 102 103 104 105 106 @staticmethod def get_active_running_notifications () -> int : \"\"\" WARNING! This is wildly inaccurate. Does an attempt to get the number of active running notifications. However, if a user snoozed or deleted the notification, we don't get an update. \"\"\" return len ( _NOTIFICATION_MAP ) CallbackExecutorThread Bases: Thread Background threat that checks each 0.1 second whether there are any callbacks that it should execute. Source code in mac_notifications/manager.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 class CallbackExecutorThread ( Thread ): \"\"\" Background threat that checks each 0.1 second whether there are any callbacks that it should execute. \"\"\" def __init__ ( self , keep_running : Event , callback_queue : SimpleQueue ): super () . __init__ () self . event_indicating_to_continue = keep_running self . callback_queue = callback_queue def run ( self ) -> None : while self . event_indicating_to_continue . is_set (): self . drain_queue () time . sleep ( 0.1 ) def drain_queue ( self ) -> None : \"\"\" This drains the Callback Queue. When there is a notification for which a callback should be fired, this event is added to the `callback_queue`. This background Threat is then responsible for listening in on the callback_queue and when there is a callback it should execute, it executes it. \"\"\" while not self . callback_queue . empty (): msg = self . callback_queue . get () notification_uid , event_id , reply_text = msg if notification_uid not in _NOTIFICATION_MAP : logger . debug ( f \"Received a notification interaction for { notification_uid } which we don't know.\" ) continue if event_id == \"action_button_clicked\" : notification_config = _NOTIFICATION_MAP . pop ( notification_uid ) logger . debug ( f \"Executing reply callback for notification { notification_config . title } .\" ) if notification_config . action_callback is None : raise ValueError ( f \"Notifications action button pressed without callback: { notification_config } .\" ) else : notification_config . action_callback () elif event_id == \"reply_button_clicked\" : notification_config = _NOTIFICATION_MAP . pop ( notification_uid ) logger . debug ( f \"Executing reply callback for notification { notification_config . title } , { reply_text } .\" ) if notification_config . reply_callback is None : raise ValueError ( f \"Notifications reply button pressed without callback: { notification_config } .\" ) else : notification_config . reply_callback ( reply_text ) else : raise ValueError ( f \"Unknown event_id: { event_id } .\" ) clear_notification_from_existence ( notification_uid ) drain_queue () This drains the Callback Queue. When there is a notification for which a callback should be fired, this event is added to the callback_queue . This background Threat is then responsible for listening in on the callback_queue and when there is a callback it should execute, it executes it. Source code in mac_notifications/manager.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 def drain_queue ( self ) -> None : \"\"\" This drains the Callback Queue. When there is a notification for which a callback should be fired, this event is added to the `callback_queue`. This background Threat is then responsible for listening in on the callback_queue and when there is a callback it should execute, it executes it. \"\"\" while not self . callback_queue . empty (): msg = self . callback_queue . get () notification_uid , event_id , reply_text = msg if notification_uid not in _NOTIFICATION_MAP : logger . debug ( f \"Received a notification interaction for { notification_uid } which we don't know.\" ) continue if event_id == \"action_button_clicked\" : notification_config = _NOTIFICATION_MAP . pop ( notification_uid ) logger . debug ( f \"Executing reply callback for notification { notification_config . title } .\" ) if notification_config . action_callback is None : raise ValueError ( f \"Notifications action button pressed without callback: { notification_config } .\" ) else : notification_config . action_callback () elif event_id == \"reply_button_clicked\" : notification_config = _NOTIFICATION_MAP . pop ( notification_uid ) logger . debug ( f \"Executing reply callback for notification { notification_config . title } , { reply_text } .\" ) if notification_config . reply_callback is None : raise ValueError ( f \"Notifications reply button pressed without callback: { notification_config } .\" ) else : notification_config . reply_callback ( reply_text ) else : raise ValueError ( f \"Unknown event_id: { event_id } .\" ) clear_notification_from_existence ( notification_uid )","title":"Notification Manager"},{"location":"code/manager/#notification-manager","text":"The module that is responsible for managing the notifications over time & enabling callbacks to be executed.","title":"Notification Manager"},{"location":"code/manager/#mac_notifications.manager.NotificationManager","text":"The NotificationManager is responsible for managing the notifications. This includes the following: - Starting new notifications. - Starting the Callback Executor thread in the background. Source code in mac_notifications/manager.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 class NotificationManager ( metaclass = Singleton ): \"\"\" The NotificationManager is responsible for managing the notifications. This includes the following: - Starting new notifications. - Starting the Callback Executor thread in the background. \"\"\" def __init__ ( self ): self . _callback_queue : SimpleQueue = SimpleQueue () self . _callback_executor_event : Event = Event () self . _callback_executor_thread : CallbackExecutorThread | None = None self . _callback_listener_process : NotificationProcess | None = None # Specify that once we stop our application, self.cleanup should run atexit . register ( self . cleanup ) # Specify that when we get a keyboard interrupt, this function should handle it signal . signal ( signal . SIGINT , handler = self . catch_keyboard_interrupt ) def create_callback_executor_thread ( self ) -> None : \"\"\"Creates the callback executor thread and sets the _callback_executor_event.\"\"\" if not ( self . _callback_executor_thread and self . _callback_executor_thread . is_alive ()): self . _callback_executor_thread = CallbackExecutorThread ( keep_running = self . _callback_executor_event , callback_queue = self . _callback_queue , ) self . _callback_executor_event . set () self . _callback_executor_thread . start () def create_notification ( self , notification_config : NotificationConfig ) -> Notification : \"\"\" Create a notification and the corresponding processes if required for a notification with callbacks. :param notification_config: The configuration for the notification. \"\"\" json_config = notification_config . to_json_notification () if not notification_config . contains_callback or self . _callback_listener_process is not None : # We can send it directly and kill the process after as we don't need to listen for callbacks. new_process = NotificationProcess ( json_config , None ) new_process . start () new_process . join ( timeout = 5 ) else : # We need to also start a listener, so we send the json through a separate process. self . _callback_listener_process = NotificationProcess ( json_config , self . _callback_queue ) self . _callback_listener_process . start () self . create_callback_executor_thread () if notification_config . contains_callback : _FIFO_LIST . append ( notification_config . uid ) _NOTIFICATION_MAP [ notification_config . uid ] = notification_config self . clear_old_notifications () return Notification ( notification_config . uid ) @staticmethod def clear_old_notifications () -> None : \"\"\"Removes old notifications when we are passed our threshold.\"\"\" while len ( _FIFO_LIST ) > _MAX_NUMBER_OF_CALLBACKS_TO_TRACK : clear_notification_from_existence ( _FIFO_LIST . pop ( 0 )) @staticmethod def get_active_running_notifications () -> int : \"\"\" WARNING! This is wildly inaccurate. Does an attempt to get the number of active running notifications. However, if a user snoozed or deleted the notification, we don't get an update. \"\"\" return len ( _NOTIFICATION_MAP ) def catch_keyboard_interrupt ( self , * args ) -> None : \"\"\"We catch the keyboard interrupt but also pass it onto the user program.\"\"\" self . cleanup () sys . exit ( signal . SIGINT ) def cleanup ( self ) -> None : \"\"\"Stop all processes related to the Notification callback handling.\"\"\" if self . _callback_executor_thread : self . _callback_executor_event . clear () self . _callback_executor_thread . join () if self . _callback_listener_process : self . _callback_listener_process . kill () self . _callback_executor_thread = None self . _callback_listener_process = None _NOTIFICATION_MAP . clear () _FIFO_LIST . clear ()","title":"NotificationManager"},{"location":"code/manager/#mac_notifications.manager.NotificationManager.catch_keyboard_interrupt","text":"We catch the keyboard interrupt but also pass it onto the user program. Source code in mac_notifications/manager.py 108 109 110 111 def catch_keyboard_interrupt ( self , * args ) -> None : \"\"\"We catch the keyboard interrupt but also pass it onto the user program.\"\"\" self . cleanup () sys . exit ( signal . SIGINT )","title":"catch_keyboard_interrupt"},{"location":"code/manager/#mac_notifications.manager.NotificationManager.cleanup","text":"Stop all processes related to the Notification callback handling. Source code in mac_notifications/manager.py 113 114 115 116 117 118 119 120 121 122 123 def cleanup ( self ) -> None : \"\"\"Stop all processes related to the Notification callback handling.\"\"\" if self . _callback_executor_thread : self . _callback_executor_event . clear () self . _callback_executor_thread . join () if self . _callback_listener_process : self . _callback_listener_process . kill () self . _callback_executor_thread = None self . _callback_listener_process = None _NOTIFICATION_MAP . clear () _FIFO_LIST . clear ()","title":"cleanup"},{"location":"code/manager/#mac_notifications.manager.NotificationManager.clear_old_notifications","text":"Removes old notifications when we are passed our threshold. Source code in mac_notifications/manager.py 93 94 95 96 97 @staticmethod def clear_old_notifications () -> None : \"\"\"Removes old notifications when we are passed our threshold.\"\"\" while len ( _FIFO_LIST ) > _MAX_NUMBER_OF_CALLBACKS_TO_TRACK : clear_notification_from_existence ( _FIFO_LIST . pop ( 0 ))","title":"clear_old_notifications"},{"location":"code/manager/#mac_notifications.manager.NotificationManager.create_callback_executor_thread","text":"Creates the callback executor thread and sets the _callback_executor_event. Source code in mac_notifications/manager.py 60 61 62 63 64 65 66 67 68 def create_callback_executor_thread ( self ) -> None : \"\"\"Creates the callback executor thread and sets the _callback_executor_event.\"\"\" if not ( self . _callback_executor_thread and self . _callback_executor_thread . is_alive ()): self . _callback_executor_thread = CallbackExecutorThread ( keep_running = self . _callback_executor_event , callback_queue = self . _callback_queue , ) self . _callback_executor_event . set () self . _callback_executor_thread . start ()","title":"create_callback_executor_thread"},{"location":"code/manager/#mac_notifications.manager.NotificationManager.create_notification","text":"Create a notification and the corresponding processes if required for a notification with callbacks. Parameters: Name Type Description Default notification_config NotificationConfig The configuration for the notification. required Source code in mac_notifications/manager.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def create_notification ( self , notification_config : NotificationConfig ) -> Notification : \"\"\" Create a notification and the corresponding processes if required for a notification with callbacks. :param notification_config: The configuration for the notification. \"\"\" json_config = notification_config . to_json_notification () if not notification_config . contains_callback or self . _callback_listener_process is not None : # We can send it directly and kill the process after as we don't need to listen for callbacks. new_process = NotificationProcess ( json_config , None ) new_process . start () new_process . join ( timeout = 5 ) else : # We need to also start a listener, so we send the json through a separate process. self . _callback_listener_process = NotificationProcess ( json_config , self . _callback_queue ) self . _callback_listener_process . start () self . create_callback_executor_thread () if notification_config . contains_callback : _FIFO_LIST . append ( notification_config . uid ) _NOTIFICATION_MAP [ notification_config . uid ] = notification_config self . clear_old_notifications () return Notification ( notification_config . uid )","title":"create_notification"},{"location":"code/manager/#mac_notifications.manager.NotificationManager.get_active_running_notifications","text":"WARNING! This is wildly inaccurate. Does an attempt to get the number of active running notifications. However, if a user snoozed or deleted the notification, we don't get an update. Source code in mac_notifications/manager.py 99 100 101 102 103 104 105 106 @staticmethod def get_active_running_notifications () -> int : \"\"\" WARNING! This is wildly inaccurate. Does an attempt to get the number of active running notifications. However, if a user snoozed or deleted the notification, we don't get an update. \"\"\" return len ( _NOTIFICATION_MAP )","title":"get_active_running_notifications"},{"location":"code/manager/#mac_notifications.manager.CallbackExecutorThread","text":"Bases: Thread Background threat that checks each 0.1 second whether there are any callbacks that it should execute. Source code in mac_notifications/manager.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 class CallbackExecutorThread ( Thread ): \"\"\" Background threat that checks each 0.1 second whether there are any callbacks that it should execute. \"\"\" def __init__ ( self , keep_running : Event , callback_queue : SimpleQueue ): super () . __init__ () self . event_indicating_to_continue = keep_running self . callback_queue = callback_queue def run ( self ) -> None : while self . event_indicating_to_continue . is_set (): self . drain_queue () time . sleep ( 0.1 ) def drain_queue ( self ) -> None : \"\"\" This drains the Callback Queue. When there is a notification for which a callback should be fired, this event is added to the `callback_queue`. This background Threat is then responsible for listening in on the callback_queue and when there is a callback it should execute, it executes it. \"\"\" while not self . callback_queue . empty (): msg = self . callback_queue . get () notification_uid , event_id , reply_text = msg if notification_uid not in _NOTIFICATION_MAP : logger . debug ( f \"Received a notification interaction for { notification_uid } which we don't know.\" ) continue if event_id == \"action_button_clicked\" : notification_config = _NOTIFICATION_MAP . pop ( notification_uid ) logger . debug ( f \"Executing reply callback for notification { notification_config . title } .\" ) if notification_config . action_callback is None : raise ValueError ( f \"Notifications action button pressed without callback: { notification_config } .\" ) else : notification_config . action_callback () elif event_id == \"reply_button_clicked\" : notification_config = _NOTIFICATION_MAP . pop ( notification_uid ) logger . debug ( f \"Executing reply callback for notification { notification_config . title } , { reply_text } .\" ) if notification_config . reply_callback is None : raise ValueError ( f \"Notifications reply button pressed without callback: { notification_config } .\" ) else : notification_config . reply_callback ( reply_text ) else : raise ValueError ( f \"Unknown event_id: { event_id } .\" ) clear_notification_from_existence ( notification_uid )","title":"CallbackExecutorThread"},{"location":"code/manager/#mac_notifications.manager.CallbackExecutorThread.drain_queue","text":"This drains the Callback Queue. When there is a notification for which a callback should be fired, this event is added to the callback_queue . This background Threat is then responsible for listening in on the callback_queue and when there is a callback it should execute, it executes it. Source code in mac_notifications/manager.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 def drain_queue ( self ) -> None : \"\"\" This drains the Callback Queue. When there is a notification for which a callback should be fired, this event is added to the `callback_queue`. This background Threat is then responsible for listening in on the callback_queue and when there is a callback it should execute, it executes it. \"\"\" while not self . callback_queue . empty (): msg = self . callback_queue . get () notification_uid , event_id , reply_text = msg if notification_uid not in _NOTIFICATION_MAP : logger . debug ( f \"Received a notification interaction for { notification_uid } which we don't know.\" ) continue if event_id == \"action_button_clicked\" : notification_config = _NOTIFICATION_MAP . pop ( notification_uid ) logger . debug ( f \"Executing reply callback for notification { notification_config . title } .\" ) if notification_config . action_callback is None : raise ValueError ( f \"Notifications action button pressed without callback: { notification_config } .\" ) else : notification_config . action_callback () elif event_id == \"reply_button_clicked\" : notification_config = _NOTIFICATION_MAP . pop ( notification_uid ) logger . debug ( f \"Executing reply callback for notification { notification_config . title } , { reply_text } .\" ) if notification_config . reply_callback is None : raise ValueError ( f \"Notifications reply button pressed without callback: { notification_config } .\" ) else : notification_config . reply_callback ( reply_text ) else : raise ValueError ( f \"Unknown event_id: { event_id } .\" ) clear_notification_from_existence ( notification_uid )","title":"drain_queue"},{"location":"code/notification_config/","text":"Notification config The dataclasses that represent a Notification configuration. The first one is for the main process, the second one is for the actual creation & waiting for callback process. NotificationConfig dataclass The standard representation of a Notifications. This is used inside the main process. Source code in mac_notifications/notification_config.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 @dataclass class NotificationConfig : \"\"\" The standard representation of a Notifications. This is used inside the main process. \"\"\" title : str subtitle : str | None text : str | None icon : str | None delay : timedelta action_button_str : str | None action_callback : Callable [[], None ] | None reply_button_str : str | None reply_callback : Callable [[ str ], None ] | None snooze_button_str : str | None sound : str | None uid : str = field ( default_factory = lambda : uuid . uuid4 () . hex ) @property def contains_callback ( self ) -> bool : return bool ( self . action_callback or self . reply_callback ) @staticmethod def c_compliant ( a_str : str | None ) -> str | None : return \"\" . join ( filter ( lambda x : bool ( str . isalnum or str . isspace ), a_str )) if a_str else None # type: ignore def to_json_notification ( self ) -> \"JSONNotificationConfig\" : return JSONNotificationConfig ( title = NotificationConfig . c_compliant ( self . title ) or \"Notification title\" , subtitle = NotificationConfig . c_compliant ( self . subtitle ), text = NotificationConfig . c_compliant ( self . text ), icon = self . icon , sound = self . sound , delay_in_seconds = ( self . delay or timedelta ()) . total_seconds (), action_button_str = NotificationConfig . c_compliant ( self . action_button_str ), action_callback_present = bool ( self . action_callback ), reply_button_str = NotificationConfig . c_compliant ( self . reply_button_str ), reply_callback_present = bool ( self . reply_callback ), snooze_button_str = NotificationConfig . c_compliant ( self . snooze_button_str ), uid = self . uid , ) JSONNotificationConfig dataclass This notification configuration class that only contains serializable parts. This class is required because waiting for user interaction with a notification is a blocking operation. Because it is a blocking operation, if we want to be able to receive any user interaction from the notification, without completely halting/freezing our main process, we need to open it in a background process. However, to be able to transfer the data from the notification to the other process, all the arguments should be serializable. As callbacks/functions are not serializable, we replaced them by booleans on whether it contained a callback or not. Once a callback should be triggered, we send a message over a multiprocessing Queue and trigger the callback in the main process. Source code in mac_notifications/notification_config.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 @dataclass class JSONNotificationConfig : \"\"\" This notification configuration class that only contains serializable parts. This class is required because waiting for user interaction with a notification is a blocking operation. Because it is a blocking operation, if we want to be able to receive any user interaction from the notification, without completely halting/freezing our main process, we need to open it in a background process. However, to be able to transfer the data from the notification to the other process, all the arguments should be serializable. As callbacks/functions are not serializable, we replaced them by booleans on whether it contained a callback or not. Once a callback should be triggered, we send a message over a multiprocessing Queue and trigger the callback in the main process. \"\"\" title : str subtitle : str | None text : str | None icon : str | None sound : str | None delay_in_seconds : float action_button_str : str | None action_callback_present : bool reply_button_str : str | None reply_callback_present : bool snooze_button_str : str | None uid : str @property def contains_callback ( self ) -> bool : return bool ( self . action_callback_present or self . reply_callback_present )","title":"Config"},{"location":"code/notification_config/#notification-config","text":"The dataclasses that represent a Notification configuration. The first one is for the main process, the second one is for the actual creation & waiting for callback process.","title":"Notification config"},{"location":"code/notification_config/#mac_notifications.notification_config.NotificationConfig","text":"The standard representation of a Notifications. This is used inside the main process. Source code in mac_notifications/notification_config.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 @dataclass class NotificationConfig : \"\"\" The standard representation of a Notifications. This is used inside the main process. \"\"\" title : str subtitle : str | None text : str | None icon : str | None delay : timedelta action_button_str : str | None action_callback : Callable [[], None ] | None reply_button_str : str | None reply_callback : Callable [[ str ], None ] | None snooze_button_str : str | None sound : str | None uid : str = field ( default_factory = lambda : uuid . uuid4 () . hex ) @property def contains_callback ( self ) -> bool : return bool ( self . action_callback or self . reply_callback ) @staticmethod def c_compliant ( a_str : str | None ) -> str | None : return \"\" . join ( filter ( lambda x : bool ( str . isalnum or str . isspace ), a_str )) if a_str else None # type: ignore def to_json_notification ( self ) -> \"JSONNotificationConfig\" : return JSONNotificationConfig ( title = NotificationConfig . c_compliant ( self . title ) or \"Notification title\" , subtitle = NotificationConfig . c_compliant ( self . subtitle ), text = NotificationConfig . c_compliant ( self . text ), icon = self . icon , sound = self . sound , delay_in_seconds = ( self . delay or timedelta ()) . total_seconds (), action_button_str = NotificationConfig . c_compliant ( self . action_button_str ), action_callback_present = bool ( self . action_callback ), reply_button_str = NotificationConfig . c_compliant ( self . reply_button_str ), reply_callback_present = bool ( self . reply_callback ), snooze_button_str = NotificationConfig . c_compliant ( self . snooze_button_str ), uid = self . uid , )","title":"NotificationConfig"},{"location":"code/notification_config/#mac_notifications.notification_config.JSONNotificationConfig","text":"This notification configuration class that only contains serializable parts. This class is required because waiting for user interaction with a notification is a blocking operation. Because it is a blocking operation, if we want to be able to receive any user interaction from the notification, without completely halting/freezing our main process, we need to open it in a background process. However, to be able to transfer the data from the notification to the other process, all the arguments should be serializable. As callbacks/functions are not serializable, we replaced them by booleans on whether it contained a callback or not. Once a callback should be triggered, we send a message over a multiprocessing Queue and trigger the callback in the main process. Source code in mac_notifications/notification_config.py 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 @dataclass class JSONNotificationConfig : \"\"\" This notification configuration class that only contains serializable parts. This class is required because waiting for user interaction with a notification is a blocking operation. Because it is a blocking operation, if we want to be able to receive any user interaction from the notification, without completely halting/freezing our main process, we need to open it in a background process. However, to be able to transfer the data from the notification to the other process, all the arguments should be serializable. As callbacks/functions are not serializable, we replaced them by booleans on whether it contained a callback or not. Once a callback should be triggered, we send a message over a multiprocessing Queue and trigger the callback in the main process. \"\"\" title : str subtitle : str | None text : str | None icon : str | None sound : str | None delay_in_seconds : float action_button_str : str | None action_callback_present : bool reply_button_str : str | None reply_callback_present : bool snooze_button_str : str | None uid : str @property def contains_callback ( self ) -> bool : return bool ( self . action_callback_present or self . reply_callback_present )","title":"JSONNotificationConfig"},{"location":"code/notification_sender/","text":"Notification sender This is the bread and butter of our application \u26a1\ufe0f! create_notification ( config , queue_to_submit_events_to ) Create a notification and possibly listed & report about notification activity. Parameters: Name Type Description Default config JSONNotificationConfig The configuration of the notification to send. required queue_to_submit_events_to SimpleQueue | None The Queue to submit user activity related to the callbacks to. If this argument is passed, it will start the event listener after it created the Notifications. If this is None, it will only create the notification. required Source code in mac_notifications/notification_sender.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def create_notification ( config : JSONNotificationConfig , queue_to_submit_events_to : SimpleQueue | None ) -> Any : \"\"\" Create a notification and possibly listed & report about notification activity. :param config: The configuration of the notification to send. :param queue_to_submit_events_to: The Queue to submit user activity related to the callbacks to. If this argument is passed, it will start the event listener after it created the Notifications. If this is None, it will only create the notification. \"\"\" class MacOSNotification ( NSObject ): def send ( self ): \"\"\"Sending of the notification\"\"\" notification = NSUserNotification . alloc () . init () notification . setIdentifier_ ( config . uid ) if config is not None : notification . setTitle_ ( config . title ) if config . subtitle is not None : notification . setSubtitle_ ( config . subtitle ) if config . text is not None : notification . setInformativeText_ ( config . text ) if config . sound is not None : notification . setSoundName_ ( config . sound ) if config . icon is not None : url = NSURL . alloc () . initWithString_ ( f \"file:// { config . icon } \" ) image = NSImage . alloc () . initWithContentsOfURL_ ( url ) notification . setContentImage_ ( image ) # Notification buttons (main action button and other button) if config . action_button_str : notification . setActionButtonTitle_ ( config . action_button_str ) notification . setHasActionButton_ ( True ) if config . snooze_button_str : notification . setOtherButtonTitle_ ( config . snooze_button_str ) if config . reply_callback_present : notification . setHasReplyButton_ ( True ) if config . reply_button_str : notification . setResponsePlaceholder_ ( config . reply_button_str ) NSUserNotificationCenter . defaultUserNotificationCenter () . setDelegate_ ( self ) # Setting delivery date as current date + delay (in seconds) notification . setDeliveryDate_ ( NSDate . dateWithTimeInterval_sinceDate_ ( config . delay_in_seconds , NSDate . date ()) ) # Schedule the notification send NSUserNotificationCenter . defaultUserNotificationCenter () . scheduleNotification_ ( notification ) # Wait for the notification CallBack to happen. if queue_to_submit_events_to : logger . debug ( \"Started listening for user interactions with notifications.\" ) AppHelper . runConsoleEventLoop () def userNotificationCenter_didDeliverNotification_ ( self , center : \"_NSConcreteUserNotificationCenter\" , notif : \"_NSConcreteUserNotification\" # type: ignore # noqa ) -> None : \"\"\"Respond to the delivering of the notification.\"\"\" logger . debug ( f \"Delivered: { notif . identifier () } \" ) def userNotificationCenter_didActivateNotification_ ( self , center : \"_NSConcreteUserNotificationCenter\" , notif : \"_NSConcreteUserNotification\" # type: ignore # noqa ) -> None : \"\"\" Respond to a user interaction with the notification. \"\"\" identifier = notif . identifier () response = notif . response () activation_type = notif . activationType () if queue_to_submit_events_to is None : raise ValueError ( \"Queue should not be None here.\" ) else : queue : SimpleQueue = queue_to_submit_events_to logger . debug ( f \"User interacted with { identifier } with activationType { activation_type } .\" ) if activation_type == 1 : # user clicked on the notification (not on a button) pass elif activation_type == 2 : # user clicked on the action button queue . put (( identifier , \"action_button_clicked\" , \"\" )) elif activation_type == 3 : # User clicked on the reply button queue . put (( identifier , \"reply_button_clicked\" , response . string ())) # create the new notification new_notif = MacOSNotification . alloc () . init () # return notification return new_notif","title":"Sender"},{"location":"code/notification_sender/#notification-sender","text":"This is the bread and butter of our application \u26a1\ufe0f!","title":"Notification sender"},{"location":"code/notification_sender/#mac_notifications.notification_sender.create_notification","text":"Create a notification and possibly listed & report about notification activity. Parameters: Name Type Description Default config JSONNotificationConfig The configuration of the notification to send. required queue_to_submit_events_to SimpleQueue | None The Queue to submit user activity related to the callbacks to. If this argument is passed, it will start the event listener after it created the Notifications. If this is None, it will only create the notification. required Source code in mac_notifications/notification_sender.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 def create_notification ( config : JSONNotificationConfig , queue_to_submit_events_to : SimpleQueue | None ) -> Any : \"\"\" Create a notification and possibly listed & report about notification activity. :param config: The configuration of the notification to send. :param queue_to_submit_events_to: The Queue to submit user activity related to the callbacks to. If this argument is passed, it will start the event listener after it created the Notifications. If this is None, it will only create the notification. \"\"\" class MacOSNotification ( NSObject ): def send ( self ): \"\"\"Sending of the notification\"\"\" notification = NSUserNotification . alloc () . init () notification . setIdentifier_ ( config . uid ) if config is not None : notification . setTitle_ ( config . title ) if config . subtitle is not None : notification . setSubtitle_ ( config . subtitle ) if config . text is not None : notification . setInformativeText_ ( config . text ) if config . sound is not None : notification . setSoundName_ ( config . sound ) if config . icon is not None : url = NSURL . alloc () . initWithString_ ( f \"file:// { config . icon } \" ) image = NSImage . alloc () . initWithContentsOfURL_ ( url ) notification . setContentImage_ ( image ) # Notification buttons (main action button and other button) if config . action_button_str : notification . setActionButtonTitle_ ( config . action_button_str ) notification . setHasActionButton_ ( True ) if config . snooze_button_str : notification . setOtherButtonTitle_ ( config . snooze_button_str ) if config . reply_callback_present : notification . setHasReplyButton_ ( True ) if config . reply_button_str : notification . setResponsePlaceholder_ ( config . reply_button_str ) NSUserNotificationCenter . defaultUserNotificationCenter () . setDelegate_ ( self ) # Setting delivery date as current date + delay (in seconds) notification . setDeliveryDate_ ( NSDate . dateWithTimeInterval_sinceDate_ ( config . delay_in_seconds , NSDate . date ()) ) # Schedule the notification send NSUserNotificationCenter . defaultUserNotificationCenter () . scheduleNotification_ ( notification ) # Wait for the notification CallBack to happen. if queue_to_submit_events_to : logger . debug ( \"Started listening for user interactions with notifications.\" ) AppHelper . runConsoleEventLoop () def userNotificationCenter_didDeliverNotification_ ( self , center : \"_NSConcreteUserNotificationCenter\" , notif : \"_NSConcreteUserNotification\" # type: ignore # noqa ) -> None : \"\"\"Respond to the delivering of the notification.\"\"\" logger . debug ( f \"Delivered: { notif . identifier () } \" ) def userNotificationCenter_didActivateNotification_ ( self , center : \"_NSConcreteUserNotificationCenter\" , notif : \"_NSConcreteUserNotification\" # type: ignore # noqa ) -> None : \"\"\" Respond to a user interaction with the notification. \"\"\" identifier = notif . identifier () response = notif . response () activation_type = notif . activationType () if queue_to_submit_events_to is None : raise ValueError ( \"Queue should not be None here.\" ) else : queue : SimpleQueue = queue_to_submit_events_to logger . debug ( f \"User interacted with { identifier } with activationType { activation_type } .\" ) if activation_type == 1 : # user clicked on the notification (not on a button) pass elif activation_type == 2 : # user clicked on the action button queue . put (( identifier , \"action_button_clicked\" , \"\" )) elif activation_type == 3 : # User clicked on the reply button queue . put (( identifier , \"reply_button_clicked\" , response . string ())) # create the new notification new_notif = MacOSNotification . alloc () . init () # return notification return new_notif","title":"create_notification"},{"location":"code/singleton/","text":"Singleton A metaclass to ensure we don't instantiate this class twice. One object will be created at the start of our application. After this, it will always use this specific instance. Singleton Bases: type Credits go to https://www.linkedin.com/pulse/writing-thread-safe-singleton-class-python-saurabh-singh/ Source code in mac_notifications/singleton.py 7 8 9 10 11 12 13 14 15 16 17 18 19 class Singleton ( type ): \"\"\"Credits go to https://www.linkedin.com/pulse/writing-thread-safe-singleton-class-python-saurabh-singh/\"\"\" _instances : Dict [ Type , Any ] = {} _lock : Lock = Lock () def __call__ ( cls , * args , ** kwargs ): with cls . _lock : if cls not in cls . _instances : instance = super () . __call__ ( * args , ** kwargs ) cls . _instances [ cls ] = instance return cls . _instances [ cls ]","title":"Singleton"},{"location":"code/singleton/#singleton","text":"A metaclass to ensure we don't instantiate this class twice. One object will be created at the start of our application. After this, it will always use this specific instance.","title":"Singleton"},{"location":"code/singleton/#mac_notifications.singleton.Singleton","text":"Bases: type Credits go to https://www.linkedin.com/pulse/writing-thread-safe-singleton-class-python-saurabh-singh/ Source code in mac_notifications/singleton.py 7 8 9 10 11 12 13 14 15 16 17 18 19 class Singleton ( type ): \"\"\"Credits go to https://www.linkedin.com/pulse/writing-thread-safe-singleton-class-python-saurabh-singh/\"\"\" _instances : Dict [ Type , Any ] = {} _lock : Lock = Lock () def __call__ ( cls , * args , ** kwargs ): with cls . _lock : if cls not in cls . _instances : instance = super () . __call__ ( * args , ** kwargs ) cls . _instances [ cls ] = instance return cls . _instances [ cls ]","title":"Singleton"}]}